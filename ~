
import __future__
import cv2
import matplotlib
import numpy as np

# For the error: Exception ignored in: <bound method Image.del of <tkinter.PhotoImage object at 0x7f1b5f86a710>> Traceback (most recent call last):
matplotlib.use('Agg')
from mpl_toolkits import mplot3d
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import pyplot as plt
plt.rcParams.update({'figure.max_open_warning': 0})
import time
import math

'''
Below code work for straight lines only
def show_image(title, img):
    cv2.imwrite("/constraint_model/images/{}.png".format(title), img)

SIZE = 500
img = cv2.imread("/constraint_model/images/new_image_m.png")
img = cv2.resize(img, (SIZE, SIZE))

gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# detect edges
edges = cv2.Canny(gray, 150, 300)



show_image("edges", edges)

# create mask
mask = np.zeros(img.shape[:2], dtype = "uint8") # 0 - 255 = 8 bits

# white pentagon
#pts = np.array([[0, SIZE * 3 / 4], [SIZE / 2, SIZE / 2], [SIZE, SIZE * 3 / 4], [SIZE, SIZE], [0, SIZE]], np.int32)

# black triangle
#pts2 = np.array([[SIZE / 2, 0], [SIZE / 4, SIZE], [SIZE * 3 / 4, SIZE]], np.int32)

#cv2.fillPoly(mask, [pts], 255)

#cv2.fillPoly(mask, [pts2], 0)

#show_image("mask", mask)

# get lines
# (x1, y1, x2, y2)
lines = cv2.HoughLinesP(
    edges,
    rho=1.0,
    theta=np.pi/180,
    threshold=20,
    minLineLength=30,
    maxLineGap=30        
)

# draw lines
line_img = np.zeros((img.shape[0], img.shape[1], 3), dtype=np.uint8)
line_color = [0, 255, 0]
line_thickness = 2
dot_color = [0, 255, 0]
dot_size = 3

for line in lines:
    for x1, y1, x2, y2 in line:
        print(line)
        cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_thickness)
        cv2.circle(line_img, (x1, y1), dot_size, dot_color, -1)
        cv2.circle(line_img, (x2, y2), dot_size, dot_color, -1)
        
line_img = cv2.bitwise_and(line_img, line_img)

overlay = cv2.addWeighted(img, 0.8, line_img, 1.0, 0.0)

show_image("Overlay", overlay)

# Based on this: https://stackoverflow.com/questions/63727525/how-to-connect-broken-lines-that-cannot-be-connected-by-erosion-and-dilation, 
# find the m and b and line equation, then find other line points are touching 

def calculate_slope(line_object):
    x_point1 = line_object[0]
    y_point1 = line_object[1]
    x_point2 = line_object[2]
    y_point2 = line_object[3]

    m = abs((y_point2 - y_point1) / (x_point2 - x_point1))
    m = float("{:.2f}".format(m))
    return m

    
for index in range(len(lines)):
    x1, y1, x2, y2 = lines[index][0]
    
    # Finding the slope m = (y2-y1)/x2-x1)
    m = (y2-y1)/(x2-x1)
    b = y2-m*x2
    
    # Now we have the equation y = mx+b, check the quation can give similar points to neighbouring lines
    for n_index in range(index+1, len(lines)):
        n_x1, n_y1, n_x2, n_y2 = lines[n_index][0]
        y = m*n_x1+b
        if y==n_y1:
            #print("y:{} and y1:{}".format(y,n_y1))
            cv2.line(overlay,
                pt1=(n_x1, n_y1),
                pt2=(x2, y2),
                color=(0, 255, 0),
                thickness=3)
            
    show_image("Overlay1", overlay)
        
'''    

img = cv2.imread("/constraint_model/images/new_image_m.png")
print(img.shape)
(winW, winH) = (40, 40)
step_size = 40
nonzero = img.nonzero()
nonzeroy = np.array(nonzero[0])
nonzerox = np.array(nonzero[1])
def sliding_window(image, stepSize, windowSize):
    # slide a window across the image
	for y in range(0, image.shape[0], stepSize):
		for x in range(0, image.shape[1], stepSize):
			# yield the current window
			yield (x, y, image[y:y + windowSize[1], x:x + windowSize[0]])


lane_points_x = {}
lane_points_y = {}

for (x, y, window) in sliding_window(img, stepSize=step_size, windowSize=(winW, winH)):
    # if the window does not meet our desired window size, ignore it
    if window.shape[0] != winH or window.shape[1] != winW:
        continue
    # THIS IS WHERE YOU WOULD PROCESS YOUR WINDOW, SUCH AS APPLYING A
    # MACHINE LEARNING CLASSIFIER TO CLASSIFY THE CONTENTS OF THE
    # WINDOW
    # since we do not have a classifier, we'll just draw the window
    
    
    top_left_x = x
    top_left_y = y
    bottom_left_x = x
    bottom_left_y = y+winH
    
    top_right_x = x + winW
    top_right_y = y
    bottom_right_x = x + winW
    bottom_right_y = y + winH


    win_y_low = img.shape[0] - (y+step_size)
    win_y_high = img.shape[0] - y
    print("{},{}".format(win_y_low,win_y_high))
    
    #good_left_inds = ((nonzeroy >= win_y_low) & (nonzeroy < win_y_high) & 
    #    (nonzerox >= win_xleft_low) &  (nonzerox < win_xleft_high)).nonzero()[0]

    #print("{},{}".format(len(nonzerox), len(nonzeroy)))
    #print(y)

    if y in lane_points_y:
        for _y in nonzeroy:
            lane_points_y[y].append(_y)
    else:
        lane_points_y[y] = []
        for _y in nonzeroy:
            lane_points_y[y].append(_y)

    if y in lane_points_x:
        for _x in nonzerox:
            lane_points_x[y].append(_x)
    else:
        lane_points_x[y] = []
        for _x in nonzerox:
            lane_points_x[y].append(_x)

    

    '''
    clone = img.copy()
    cv2.rectangle(clone, (x, y), (x + winW, y + winH), (0, 255, 0), 2)
    cv2.imshow("Window", clone)
    cv2.waitKey(1)
    time.sleep(1)
    '''

#print(lane_points_y[0])
#print(lane_points_x[0])

x = np.array(lane_points_x[0])
y = np.array(lane_points_y[0])
lane_fit = np.polyfit(y, x, 2)
ploty = np.linspace(0, img.shape[0]-1, img.shape[0])
lane_fitx = lane_fit[0]*ploty**2 + lane_fit[1]*ploty + lane_fit[2]

img[y, x] = [255, 0, 0]

plt.imshow(img)
plt.plot(lane_fitx, ploty, color='yellow')
plt.xlim(0, img.shape[1])
plt.ylim(img.shape[0], 0)
plt.savefig('images/fit.png')


'''
min_pix = 50

for index in lane_points_x:
    x = lane_points_x[index]
    y = lane_points_y[index]
    print("{},{}".format(len(x), len(y)))
    if len(x) > min_pix:
        lane_fit = np.polyfit(y, x, 2)
        # Generate x and y values for plotting
        ploty = np.linspace(0, img.shape[0]-1, img.shape[0] )
        try:
            lane_fitx = lane_fit[0]*ploty**2 + lane_fit[1]*ploty + lane_fit[2]
        except TypeError:
            # Avoids an error if `left` and `right_fit` are still none or incorrect
            print('The function failed to fit a line!')
            lane_fitx = 1*ploty**2 + 1*ploty

        ## Visualization ##
        # Colors in the left and right lane regions
        img[y, x] = [255, 0, 0]

        # Plots the left and right polynomials on the lane lines
        plt.plot(lane_fitx, ploty, color='yellow')
plt.savefig('/constraint_model/images/lane.png')

print(img.shape)
'''
